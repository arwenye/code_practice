------

# 📦 背包问题全景分类

### 1. 基础类

- **0-1 背包**：每件物品要么选，要么不选。
- **完全背包**：物品可以无限次选。
- **多重背包**：物品最多可以选有限次（介于 0-1 和完全之间）。
- **分组背包**：物品按组划分，每组最多选一个。

------

### 2. 高维约束类

- **二维/多维背包**：物品有多个“消耗维度”，例如同时消耗重量和体积。
- **多目标背包**：不仅考虑价值，还要兼顾其他目标（例如风险、收益）。

------

### 3. 数量限制类

- **多重背包**（前面提到）：每个物品有件数上限。
- **有依赖背包**（依赖关系/树形背包）：某件物品必须在另一件物品选了之后才能选（例如“主件-附件”）。

------

### 4. 特殊结构类

- **树形背包**：物品之间形成树状依赖（例如公司分级购买软件模块，必须先买父节点）。
- **图上背包**：物品之间有图约束（例如必须买相邻点，或者禁止同时买相邻点）。

------

### 5. 变形应用类

- **混合背包**：题目中同时存在 0-1、完全、多重三类物品。
- **背包问题求方案数**：不是求最大价值，而是问一共有多少种方案能达到某种目标。
- **背包问题求最优方案集合**：不仅要最大值，还要输出选哪些物品。
- **子集和问题**：其实就是 0-1 背包的一种特殊情况（价值=重量）。

------

### 6. 高阶应用类

- **多维费用背包** + **期望价值**：常用于 AI 规划或博弈。
- **背包多解法优化**：如单调队列优化、二进制分组优化（多重背包常用）。
- **线性规划/流网络模型**：某些背包问题可以转化为最小费用流/最大流。

------

👉 总结一下：

- 基础的 **0-1、完全、多维、分组**。
- 接下来比较经典、常考的还有 **多重背包** 和 **依赖背包（树形背包）**。
- 再深入就是 **混合背包** 和 **优化技巧**（单调队列优化、多重转 0-1 等）。



# 一、0-1 背包问题

## 1️⃣ 问题描述

- **给定**：
  - n 件物品，每件物品有重量 `w[i]` 和价值 `v[i]`
  - 背包容量 `W`
- **目标**：
  - 选择若干物品放入背包，使总重量 ≤ W，总价值最大
  - **限制**：每件物品最多放一次（0 或 1 次）
- **数学表达**：

$$\text{max} \sum_{i=1}^{n} v[i] * x[i] \quad  \text{s.t. } \sum_{i=1}^{n} w[i] * x[i] \le W, \quad x[i] \in \{0,1\}$$

------

## 2️⃣ 动态规划解法

### （1）状态定义

定义一个二维 dp 数组：

$dp[i][j]$ =$ \text{前 i 个物品，容量为 j 的背包可得到的最大价值}$

- `i` 表示考虑前 i 个物品（1-based 或 0-based 都可以）
- `j` 表示背包容量
- $dp[i][j] $表示在这个状态下能得到的最大价值

------

### （2）状态转移方程

每个物品有两个选择：

1. **不放第 i 件物品**：

$dp[i][j]=dp[i−1][j]$

1. **放第 i 件物品**（前提：`j >= w[i]`）：

$dp[i][j]=dp[i−1][j−w[i]]+v[i]$

综合起来：

$$dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) \quad (\text{if } j \ge w[i])$$

------

### （3）初始化

- `dp[0][*] = 0`：0 个物品总价值为 0
- `dp[*][0] = 0`：背包容量为 0 总价值为 0

------

### （4）二维 DP 实现

```python
def knapsack_01(n, W, weights, values):
    dp = [[0] * (W+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for w in range(W+1):
            if w >= weights[i-1]:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][W]
```

- `dp[n][W]` 就是**最大总价值**

------

### （5）空间优化（滚动数组）

- 0-1 背包可以优化成一维数组
- **关键点**：容量要**倒序遍历**，保证每个物品只用一次

```python
def knapsack_01_optimized(n, W, weights, values):
    dp = [0] * (W+1)
    for i in range(n):
        for w in range(W, weights[i]-1, -1):  # 倒序
            dp[w] = max(dp[w], dp[w-weights[i]] + values[i])
    return dp[W]
```

- 倒序的原因：
  - 如果正序遍历，会导致第 i 件物品被重复使用
  - 倒序确保 `dp[w-weights[i]]` 是上一次 i 之前的状态

------

## 3️⃣ 直观理解

假设有 3 件物品：

| 物品 | 重量 w | 价值 v |
| ---- | ------ | ------ |
| 1    | 2      | 3      |
| 2    | 3      | 4      |
| 3    | 4      | 5      |

背包容量 W = 5

- dp 状态表：

| i\w  | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 0    | 3    | 3    | 3    | 3    |
| 2    | 0    | 0    | 3    | 4    | 4    | 7    |
| 3    | 0    | 0    | 3    | 4    | 5    | 7    |

- 最优解：总价值 = 7（选择物品 1 和 2）

------

### 4️⃣ 总结

- **状态定义**：$dp[i][j] = 前 i 个物品，容量 j 的最大价值$
- **状态转移**：$dp[i][j] = max(不选, 选第 i 件)$
- **优化技巧**：一维滚动数组，容量倒序遍历

------



好的，我们接下来讲 **二维背包（Two-Dimensional Knapsack）**，这是背包问题的一个经典扩展，比 0-1 背包稍复杂，但思路是类似的，只是状态和约束多了。

------

好的，我们接下来讲 **完全背包问题（Complete Knapsack / Unbounded Knapsack）**，这是 0-1 背包的一个重要变形。

------

# 二、完全背包问题

## 1️⃣ 问题描述

- **给定**：
  - n 件物品，每件物品有重量 `w[i]` 和价值 `v[i]`
  - 背包容量 W
- **目标**：
  - 选择若干物品放入背包，使总重量 ≤ W，总价值最大
  - **区别 0-1 背包**：每件物品可以**放无限次**
- **数学表达**：

$$\text{max} \sum_{i=1}^{n} v[i] * x[i] \quad  \text{s.t. } \sum_{i=1}^{n} w[i] * x[i] \le W, \quad x[i] \in \{0,1,2,...\}$$

------

## 二维数组实现完全背包

- `dp[i][j]` 表示**前 i 件物品，总容量为 j 时的最大价值**
- 注意：二维 dp 不一定必须用，现在更多是用来**帮助理解状态转移**

------

### 2️⃣ 状态转移

- 每件物品可以使用多次，所以公式和二维写法类似：

$dp[i][j] = \max(dp[i-1][j], dp[i][j-w[i]] + v[i]) \quad (\text{if } j \ge w[i])$

- **区别**：这里不是 `dp[i-1][j-w[i]]` 而是 `dp[i][j-w[i]]`
  - `dp[i][j-w[i]]` 表示**同一物品可以重复使用**
  - `dp[i-1][j]` 表示不放当前物品

------

### 3️⃣ 二维数组代码示例

```python
def knapsack_complete_2d(n, W, weights, values):
    # dp[i][j] 表示前 i 件物品，容量 j 的最大价值
    dp = [[0]*(W+1) for _ in range(n+1)]

    for i in range(1, n+1):
        w, v = weights[i-1], values[i-1]
        for j in range(W+1):
            # 不选第 i 件
            dp[i][j] = dp[i-1][j]
            # 选第 i 件（可以多次选）
            if j >= w:
                dp[i][j] = max(dp[i][j], dp[i][j-w] + v)
    
    return dp[n][W]
```

------

### 4️⃣ 关键点解释

- **二维 $dp[i][j]$**
  - i：考虑前 i 件物品
  - j：当前背包容量
- **状态转移**：
  - `dp[i-1][j]` → 不选当前物品
  - `dp[i][j-w[i]] + v[i]` → 选当前物品，容量减去重量，但依然是 `i` → 表示同一物品可以多次选

------

### 5️⃣ 示例

假设：

- 物品重量 = [2,3]
- 物品价值 = [3,4]
- 背包容量 W = 7

二维 dp 表（只列出 $dp[i][j] $变化）：

| i\j  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 0    | 3    | 3    | 6    | 6    | 9    | 9    |
| 2    | 0    | 0    | 3    | 4    | 6    | 7    | 9    | 10   |

- dp[n][W] = 10 ✅

------



## 一维数组实现

### 2️⃣ 状态定义

- 和 0-1 背包一样，我们可以定义一维 dp：

$$dp[j] = \text{容量为 j 的背包能得到的最大价值}$$

- **区别**：每件物品可以用多次，所以状态更新顺序不同

------

### 3️⃣ 状态转移

- **核心公式**：

$$dp[j] = \max(dp[j], dp[j-w[i]] + v[i])$$

- **遍历顺序**：
  - **正序遍历容量 j**：`for j in w[i]..W`
  - 原因：
    - 正序保证同一轮物品可以多次放
    - 如果倒序，会变成 0-1 背包效果，每件物品只能用一次

------

### 4️⃣ 代码实现（1D DP）

```python
def knapsack_complete(n, W, weights, values):
    dp = [0] * (W+1)
    
    for i in range(n):
        w, v = weights[i], values[i]
        for j in range(w, W+1):  # 正序遍历
            dp[j] = max(dp[j], dp[j-w] + v)
    
    return dp[W]
```

------

### 5️⃣ 与 0-1 背包对比

| 特点             | 0-1 背包                              | 完全背包                                          |
| ---------------- | ------------------------------------- | ------------------------------------------------- |
| 每件物品使用次数 | ≤1                                    | 无限                                              |
| 遍历容量顺序     | 倒序                                  | 正序                                              |
| 状态转移公式     | dp[j] = max(dp[j], dp[j-w[i]] + v[i]) | dp[j] = max(dp[j], dp[j-w[i]] + v[i])（公式一样） |
| 核心差异         | 避免重复使用                          | 允许重复使用                                      |

- **总结**：区别在容量遍历顺序，而状态定义和公式相同

------

### 6️⃣ 示例

假设：

- n = 2
- 物品重量 = [2,3]
- 物品价值 = [3,4]
- 背包容量 W = 7

#### 遍历过程（正序）：

1. 物品 1：重量 2，价值 3
   - dp[2] = max(dp[2], dp[0]+3) = 3
   - dp[4] = max(dp[4], dp[2]+3) = 6
   - dp[6] = max(dp[6], dp[4]+3) = 9
2. 物品 2：重量 3，价值 4
   - dp[3] = max(dp[3], dp[0]+4) = 4
   - dp[5] = max(dp[5], dp[2]+4) = 7
   - dp[6] = max(dp[6], dp[3]+4) = 8
   - dp[7] = max(dp[7], dp[4]+4) = 10

- **最大总价值**：dp[7] = 10
- 组合示意：可以放物品 1 两次 + 物品 2 一次 → 总重量 ≤ 7

------

### 7️⃣ 小结

- **完全背包核心**：
  - 状态公式和 0-1 背包一样
  - **正序遍历容量**保证物品可重复放
- **优化**：
  - 一维 dp 就足够
  - 空间复杂度 O(W)





# 三、二维背包问题

## 1️⃣ 问题描述

- **给定**：
  - n 件物品，每件物品有两个属性（或两个资源消耗）：
    - 比如重量 `w[i]` 和体积 `v[i]`（或时间、金钱等）
  - 背包有两个容量限制：
    - 容量 1：W1（如重量）
    - 容量 2：W2（如体积）
  - 每件物品有价值 `val[i]`
- **目标**：
  - 选择若干物品放入背包，使：
    1. 总重量 ≤ W1
    2. 总体积 ≤ W2
    3. 总价值最大
- **限制**：每件物品最多放一次（0-1 背包）
- **数学表达**：

$$\text{max} \sum_{i=1}^{n} val[i] \quad  \text{s.t. } \sum w[i]*x[i] \le W1, \quad \sum v[i]*x[i] \le W2, \quad x[i] \in \{0,1\}$$

------

## 2️⃣ 动态规划解法

### （1）状态定义

定义三维 dp 数组：

$dp[i][j][k] = \text{前 i 个物品，总重量 ≤ j，总体积 ≤ k 的最大价值}$

- `i`：前 i 个物品
- `j`：背包重量上限
- `k`：背包体积上限

------

### （2）状态转移方程

每件物品有两种选择：

1. **不放第 i 件物品**：

$dp[i][j][k] = dp[i-1][j][k]$

1. **放第 i 件物品**（条件 `j >= w[i]` 且 `k >= v[i]`）：

$dp[i][j][k] = \max(dp[i-1][j][k], dp[i-1][j-w[i]][k-v[i]] + val[i])$

- 和 0-1 背包类似，只是多了一个维度

------

### （3）初始化

- `dp[0][*][*] = 0`：0 件物品价值为 0
- `dp[*][0][*] = 0`，`dp[*][*][0] = 0`：任何容量为 0 的状态价值为 0

------

### （4）代码实现（3D DP）

```python
def knapsack_2d(n, W1, W2, weights, volumes, values):
    dp = [[[0]*(W2+1) for _ in range(W1+1)] for _ in range(n+1)]
    
    for i in range(1, n+1):
        w, v, val = weights[i-1], volumes[i-1], values[i-1]
        for j in range(W1, w-1, -1):
            for k in range(W2, v-1, -1):
                dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-w][k-v] + val)
    
    return dp[n][W1][W2]
```

------

### （5）空间优化

- 和 0-1 背包一样，可以**降维到二维 $dp[j][k]$**
- 关键是 **倒序遍历容量 j 和 k**，保证每件物品只用一次

```python
def knapsack_2d_optimized(n, W1, W2, weights, volumes, values):
    dp = [[0]*(W2+1) for _ in range(W1+1)]
    
    for i in range(n):
        w, v, val = weights[i], volumes[i], values[i]
        for j in range(W1, w-1, -1):
            for k in range(W2, v-1, -1):
                dp[j][k] = max(dp[j][k], dp[j-w][k-v] + val)
    
    return dp[W1][W2]
```

------

### 6️⃣ 直观理解

- **每一维**对应一个资源限制：重量、体积等
- 每件物品都有两种状态：选或不选
- dp[j][k] 记录在容量为 (j,k) 下的最大价值
- 倒序遍历保证**0-1 背包性质**

------

### 7️⃣ 示例

假设有 2 件物品：

| 物品 | 重量 w | 体积 v | 价值 val |
| ---- | ------ | ------ | -------- |
| 1    | 2      | 3      | 4        |
| 2    | 3      | 2      | 5        |

背包容量 W1=5, W2=5

- 最优解：选两件物品
  - 总重量 = 2+3 = 5 ≤ W1
  - 总体积 = 3+2 = 5 ≤ W2
  - 总价值 = 4+5 = 9

------

### 8️⃣ 总结

- **二维背包** = 在 0-1 背包基础上增加一个容量维度
- **核心思想**：
  - dp 多一个维度表示额外约束
  - 状态转移和 0-1 背包一致
  - 倒序遍历容量，保证每件物品只用一次

------



好的，我们接下来讲 **多维约束背包（Multi-dimensional / Multi-constraint Knapsack）**，这是完全背包和二维背包的进一步扩展，属于背包问题的高级变形。

------

# 四、多维约束背包

## 1️⃣ 问题描述

- **给定**：
  - n 件物品，每件物品有 k 种资源消耗（重量、体积、时间、金钱……）
    - 例如：`w[i][0]`、`w[i][1]`、……、`w[i][k-1]`
  - 每件物品有价值 `v[i]`
  - 背包每种资源有容量限制 `W[0]`、`W[1]`、……、`W[k-1]`
- **目标**：
  - 选择若干物品放入背包，使：
    - 每种资源总消耗 ≤ 容量
    - 总价值最大
- **限制**：
  - 可以是 0-1 背包（每件物品最多选一次）
  - 或者完全背包（每件物品可重复选）
- **数学表达**：

$$
\text{max} \sum_{i=1}^{n} v[i] * x[i] \quad  \text{s.t. } \sum_{i=1}^{n} w[i][j] * x[i] \le W[j], \quad x[i] \in \{0,1\} \text{或} \{0,1,2,...\}, \forall j=0..k-1
$$



------

## 2️⃣ 状态定义

- 多维 dp 数组：

$$
dp[i_0][i_1][i_2] \dots [i_{k-1}] = \text{容量为 }(i_0,i_1,\dots,i_{k-1})\text{ 的最大价值}
$$

- 对于 0-1 多维背包：
  - 倒序遍历每个维度容量，保证每件物品只使用一次
- 对于完全背包：
  - 正序遍历每个维度容量，允许物品重复使用

------

## 3️⃣ 状态转移公式

**0-1 多维背包**：
$$
dp[i_0][i_1]...[i_{k-1}] = \max(dp[i_0][i_1]...[i_{k-1}], dp[i_0 - w[i][0]][i_1 - w[i][1]] ... + v[i])
$$


- **约束**：$i_j >= w[i][j]$
- **倒序遍历**保证 0-1

**完全背包**：

- 公式一样
- **正序遍历**每个维度容量，允许重复使用

------

## 4️⃣ 代码示例（二维多维背包举例）

假设有 2 个资源（重量和体积），0-1 背包：

```python
def knapsack_2d_01(n, W1, W2, weights, volumes, values):
    # dp[j][k] 表示容量为 (j,k) 的最大价值
    dp = [[0]*(W2+1) for _ in range(W1+1)]
    
    for i in range(n):
        w, v, val = weights[i], volumes[i], values[i]
        # 0-1 背包 => 倒序遍历容量
        for j in range(W1, w-1, -1):
            for k in range(W2, v-1, -1):
                dp[j][k] = max(dp[j][k], dp[j-w][k-v] + val)
    
    return dp[W1][W2]
```

- **扩展到 k 维**：
  - dp 就是 k 维数组
  - 循环嵌套 k 层，倒序遍历容量

------

## 5️⃣ 示例

假设：

| 物品 | 重量 w | 体积 v | 价值 val |
| ---- | ------ | ------ | -------- |
| 1    | 2      | 3      | 4        |
| 2    | 3      | 2      | 5        |

背包容量 W1=5, W2=5

- 选择两件物品都可以，重量 5 ≤ W1，体积 5 ≤ W2
- 总价值 = 9
- dp 更新逻辑和二维背包完全一样，只是多维一般用循环嵌套

------

## 6️⃣ 注意事项

1. **维数越多，空间复杂度越高**
   - k 维 0-1 背包：$O(W1*W2*…*Wk)$
   - 优化方法：
     - 状态压缩（滚动数组）
     - 限制容量上界
2. **完全背包**：
   - 遍历顺序正序
3. **核心思想仍然是**：
   - 定义状态
   - 写转移公式
   - 遍历容量顺序



------



# 五、分组背包

 **分组背包（Grouped Knapsack / Multiple-Choice Knapsack）**是 0-1 背包的一种常见变形，逻辑和 0-1 背包相似，但有一些特殊的约束。

## 1️⃣ 问题描述

- **给定**：
  - n 组物品，每组有若干个物品
  - 每件物品有重量 `w[i][j]` 和价值 `v[i][j]`（第 i 组第 j 个物品）
  - 背包容量 W
- **约束**：
  - **每组最多选择一件物品**（可以不选）
- **目标**：
  - 总重量 ≤ W，总价值最大
- **数学表达**：

$$
\text{max} \sum_{i=1}^{n} v[i][x[i]] \quad  \text{s.t. } \sum_{i=1}^{n} w[i][x[i]] \le W, \quad x[i] \in \{0,1,...,k_i\} \text{每组选一个或不选}
$$



------

## 2️⃣ 动态规划解法

### （1）状态定义

- 和 0-1 背包一样：

$dp[j] = \text{背包容量为 j 时的最大价值}$

- 核心区别：
  - 遍历顺序仍然是 **倒序遍历容量**，保证每组只能选一件物品

------

### （2）状态转移

- 对于第 i 组：

$$
dp[j] = \max(dp[j], dp[j-w[i][k]] + v[i][k]) \quad (\text{对组中每件物品 k})
$$

- **思路**：
  1. 遍历每组物品
  2. 对组内物品遍历
  3. 更新 dp[j]

------

### （3）二维数组版本（更直观）

```python
def grouped_knapsack_2d(groups, W):
    # groups: list of list, 每组包含 (weight, value)
    n = len(groups)
    dp = [[0]*(W+1) for _ in range(n+1)]
    
    for i in range(1, n+1):
        for j in range(W+1):
            dp[i][j] = dp[i-1][j]  # 不选该组任何物品
            for w, v in groups[i-1]:  # 选组内某件物品
                if j >= w:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-w] + v)
    
    return dp[n][W]
```

------

### （4）一维数组优化

- 和 0-1 背包一样，可以用一维 dp：

```python
def grouped_knapsack_1d(groups, W):
    dp = [0]*(W+1)
    
    for group in groups:
        # 倒序遍历容量，保证组内只能选一件
        for j in range(W, -1, -1):
            for w, v in group:
                if j >= w:
                    dp[j] = max(dp[j], dp[j-w] + v)
    
    return dp[W]
```

- **核心点**：
  - 每组内部循环 → 尝试每件物品
  - 外层倒序 → 保证每组只能选一件

------

### 5️⃣ 示例

假设有 2 组：

- 组 1：[(2,3), (3,4)]
- 组 2：[(4,5), (1,2)]
- 背包容量 W = 5

**最优解**：

- 选组 1 的物品 2（重量 3，价值 4）
- 选组 2 的物品 2（重量 1，价值 2）
- 总重量 = 3+1 = 4 ≤ 5
- 总价值 = 4+2 = 6 ✅

------

### 6️⃣ 总结

- **分组背包** = 0-1 背包 + 分组约束
- **核心思想**：
  - 每组最多选一件
  - 倒序遍历容量
  - 内层循环遍历组内物品
- **拓展**：
  - 可以和多维背包结合
  - 可以和完全背包结合（组内物品可重复选）

------



# 六、 多重背包

------

## 1️⃣ 问题定义

多重背包是 0-1 背包 和 完全背包 的**结合体**：

- 有 `n` 件物品。
- 每件物品 `i` 有：
  - 重量（或体积） `w[i]`
  - 价值 `v[i]`
  - 数量上限 `c[i]`（最多可以选几件）
- 背包容量为 `W`。
- 求能装下的**最大总价值**。

------

## 2️⃣ 与其他背包的关系

- **0-1 背包**：相当于 `c[i] = 1`。
- **完全背包**：相当于 `c[i] = ∞`（无限件）。
- **多重背包**：`1 < c[i] < ∞`，介于两者之间。

------

## 3️⃣ 基本解法（朴素）

最直接的思路是：
 把每个物品拆成 `c[i]` 个独立的 0-1 物品，然后做 0-1 背包。

例如：物品 `w=2, v=3, c=3` → 拆成 `[w=2,v=3], [w=2,v=3], [w=2,v=3]`。

伪代码：

```python
for i in range(n):  # 遍历物品
    for k in range(c[i]):  # 拆成多个0-1物品
        for j in range(W, w[i]-1, -1):
            dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

**缺点**：如果 `c[i]` 很大（比如 10^5），会超时。

------

## 4️⃣ 二进制优化（常用）

核心思想：
 把数量 `c[i]` **按二进制拆分**，每个拆出来的包仍然是 0-1 背包。

例如：

- `c[i] = 13`
- 二进制拆分：`13 = 1 + 4 + 8`
- 拆成 3 个物品：
  - 重量 `1 * w[i]`, 价值 `1 * v[i]`
  - 重量 `4 * w[i]`, 价值 `4 * v[i]`
  - 重量 `8 * w[i]`, 价值 `8 * v[i]`

这样，原本要循环 13 次，现在只需 **O(log c[i])** 次。

时间复杂度：`O(n * W * log c[i])`。

------

## 5️⃣ 动态规划实现（Python）

### 版本1：二进制拆分优化

```python
def multi_knapsack(n, W, weights, values, counts):
    dp = [0] * (W + 1)
    for i in range(n):
        w, v, c = weights[i], values[i], counts[i]
        k = 1
        while c > 0:
            take = min(k, c)
            c -= take
            weight = take * w
            value = take * v
            for j in range(W, weight - 1, -1):
                dp[j] = max(dp[j], dp[j - weight] + value)
            k <<= 1  # k *= 2
    return dp[W]

# 示例
n, W = 3, 10
weights = [2, 3, 4]
values  = [4, 5, 6]
counts  = [4, 2, 3]
print(multi_knapsack(n, W, weights, values, counts))  # 输出最大价值
```



### 版本2：二进制拆分优化

```python
def multiple_knapsack_binary(n, W, w, v, c):
    """
    多重背包 - 二进制优化
    """
    items = []
    for i in range(1, n + 1):
        num = c[i]
        k = 1
        while num > 0:
            take = min(k, num)
            items.append((take * w[i], take * v[i]))
            num -= take
            k <<= 1  # 指数增长拆分

    dp = [0] * (W + 1)
    for weight, value in items:
        for j in range(W, weight - 1, -1):
            dp[j] = max(dp[j], dp[j - weight] + value)

    return dp[W]

```



------

## 6️⃣ 拓展优化

如果 `W` 特别大，还可以用 **单调队列优化**，复杂度能降到 `O(nW)`，不过思路更难。

考试/笔试里，**二进制优化法**是主流做法。

------

✅ 总结：

- **多重背包**：每种物品有数量限制。
- **解法**：
  1. 朴素拆分成多个 0-1 背包（慢）。
  2. **二进制拆分**优化成 O(log c[i]) 个物品（常用）。
  3. 进一步可用单调队列优化（进阶）。

------

要不要我接下来帮你讲 **有依赖的背包问题（树形背包）**？
 这个经常出现在大厂笔试里，比如“主件-附件”选择。



# 七、依赖背包（树形背包）

 **依赖背包（树形背包）**，也叫 **树形 DP 背包**。这是背包问题的一个变种，核心在于**物品之间有依赖关系**。

------

## 1️⃣ 问题背景

普通背包：每件物品独立，可任意选

树形背包：物品有依赖关系（父子关系），通常要求：

- 如果你选某个物品 **必须选它的父物品**
- 背包容量为 `V`
- 每个物品 i 有：
  - 重量 `w[i]`
  - 价值 `v[i]`

目标：最大化总价值

------

## 2️⃣ 树形建模

- 物品看作树的节点
- 根节点可以单独选
- 任何节点被选，必须选它的父节点
- 树形 DP 核心思想：**以子树为单位做状态转移**

------

## 3️⃣ DP 状态定义

假设 `f[u][j]` 表示：

> 以节点 `u` 为根的子树，放入容量 `j` 的最大价值

那么树形 DP 转移公式：

1. 初始化：

```python
f[u][w[u]] = v[u]  # 先把自己放进去
```

1. 遍历子节点 `v`：

- 容量从大到小（倒序）
- 合并子树的 DP：

```python
for j in range(W, w[u]-1, -1):
    for k in range(0, j - w[u] + 1):
        f[u][j] = max(f[u][j], f[u][j-k] + f[v][k])
```

- 含义：在剩余容量 `j-w[u]` 内分配给子节点，求最大价值

------

## 4️⃣ Python 示例模板

```python
def tree_knapsack(n, W, w, v, children):
    # f[u][j] 表示子树u在容量j内最大价值
    f = [[0]*(W+1) for _ in range(n+1)]

    def dfs(u):
        # 先放自己
        for j in range(w[u], W+1):
            f[u][j] = v[u]

        # 遍历每个下属（子节点）
        for child in children[u]:
            dfs(child)
            # 给子树分配容量
            for j in range(W, w[u]-1, -1):  # 父节点容量从大到小
                for k in range(0, j - w[u] + 1):  # 分配给子树容量
                    f[u][j] = max(f[u][j], f[u][j - k] + f[child][k])

    root = 1  # 假设 CEO 是根
    dfs(root)
    return max(f[root])

```

------

## 5️⃣ 小技巧

1. **优化复杂度**

- 上述模板时间复杂度 O(N*V^2)
- 可以使用**一维滚动 DP**优化空间：

```python
f[u] = [0]*(W+1)
# 子节点合并使用倒序容量
```

1. **物品拆分技巧**

- 树形背包可以结合**多重背包、完全背包**，先对每个节点做二进制拆分，然后再用树形 DP

------

## 6️⃣ 总结

- 树形背包 = 背包 + 物品依赖关系
- 核心是 **以子树为单位 DP**，保证“选子必须选父”
- DP 状态 `f[u][j]` 表示子树 u 在容量 j 内最大价值
- 复杂度通常是 O(N*V^2)，可以一维滚动优化

------





------

# 树形背包详细讲解

## 1️⃣ 问题定义

假设有 n 件物品，每件物品 i：

- 重量 w[i]
- 价值 v[i]
- 物品间有 **父子关系**（树结构）
  - 如果选物品 i，必须选它的父物品
- 背包容量为 W
- 求最大总价值

> 例子：
>
> ```
>       1
>      / \
>     2   3
>         |
>         4
> ```
>
> - 物品 2、3、4 是 1 的子节点
> - 选 4 必须选 3，选 3 必须选 1

------

## 2️⃣ DP 状态设计

### 2.1 定义状态

- $f[u][j] $表示：

> 以节点 u 为根的子树，在背包容量 j 内能获得的最大价值

- 为什么以子树为单位？
  - 因为选某个节点之前，必须先考虑它的父节点
  - 所以自然用子树 DFS 顺序处理

------

### 2.2 子树合并

假设节点 u 有子节点 v1, v2, ... vk

- 初始：$f[u][j] = 0$
- 先把自己放进去：

$f[u][j] = v[u] \quad \text{容量至少是 } w[u]$

- 然后处理子节点：

$$
\text{for each child } v \text{ of } u:    
\text{dfs(v)}    
\text{for j = W downto w[u]:}        
\text{for k = 0 to j-w[u]:}            
f[u][j] = max(f[u][j], f[u][j-k] + f[v][k])
$$



> **解释**：
>
> - j：当前剩余容量
> - k：分配给子节点 v 的容量
> - $f[v][k]$：在容量 k 内子树 v 能得到的最大价值
> - $f[u][j-k] + f[v][k]$：把容量 j 分成自己剩余 + 子树

------

### 2.3 核心思路

1. **DFS 遍历整棵树**
2. **先处理子树**（子树 DP 完成后才合并到父节点）
3. **合并策略**：背包容量在父节点处分配给自己和每个子树

> ⚡ 核心是「容量分配问题」，类似「树形背包就是每个父节点分配容量给自己和子节点子树」

------

## 3️⃣ 举例演示

背包容量 W=5，物品表：

| 节点 | 重量 | 价值 | 父节点 |
| ---- | ---- | ---- | ------ |
| 1    | 2    | 3    | -      |
| 2    | 2    | 2    | 1      |
| 3    | 1    | 2    | 1      |
| 4    | 1    | 1    | 3      |

### 3.1 从叶子开始 DFS

- 节点 4：
  - 重量=1, 价值=1
  - $f[4][0]=0$
  - $f[4][1]=1$
- 节点 3：
  - 自己 $f[3][j] = 2 (j >= 1)$
  - 合并子节点 4：
    - j=2 → 分配 k=0,1
      - $k=0 → f[3][2] = max(2, 2 + 0) = 2$
      - $k=1 → f[3][2] = max(2, 2 + 1) = 3 $✅
- 节点 1：
  - 自己$ f[1][j] = 3 (j >= 2)$
  - 合并子节点 2 和 3：
    - 枚举容量分配，求最大总价值

------

## 4️⃣ Python 实现

```python
def tree_knapsack(n, W, w, v, children):
    """
    n: 物品数量
    W: 背包容量
    w: 重量数组
    v: 价值数组
    children: 树的邻接表
    """
    f = [[0]*(W+1) for _ in range(n+1)]

    def dfs(u):
        # 先放自己
        for j in range(w[u], W+1):
            f[u][j] = v[u]

        for v_child in children[u]:
            dfs(v_child)
            for j in range(W, w[u]-1, -1):
                for k in range(0, j - w[u] + 1):
                    f[u][j] = max(f[u][j], f[u][j-k] + f[v_child][k])

    root = 1
    dfs(root)
    return max(f[root])
```

------

## 5️⃣ 小技巧与优化

1. **滚动数组优化**
   - 可以把 `f[u]` 一维数组滚动，节省空间
2. **容量剪枝**
   - 子树容量 k 不必遍历太大，剪掉大于 j-w[u] 的部分
3. **结合多重背包**
   - 树形背包中的每个节点可以是多重背包或完全背包

------

好的，我们用**动态规划五部曲**来系统讲解树形背包，彻底理清“状态、状态转移、初始化、顺序、答案”的逻辑。这样你会看到它和普通背包的联系。

------

# 树形背包五部曲

------

## 1️⃣ 明确问题

**题目背景**：

- 有 n 件物品，每件物品 i 有：
  - 重量 w[i]
  - 价值 v[i]
  - 父子关系（树结构）：选子节点必须选父节点
- 背包容量 W
- 求最大总价值

------

## 2️⃣ 定义状态

- **状态**：以节点 u 为根的子树，在容量 j 内最大价值

$f[u][j] = \text{子树 u 在容量 j 内能得到的最大价值}$

- u = 当前节点
- j = 背包容量（0~W）

> ⚡ 核心：树形背包和普通背包不同之处在于，状态是**以子树为单位**，不是单个物品。

------

## 3️⃣ 状态转移

假设 u 有子节点 v1, v2, … vk：

1. **先考虑自己**：

$f[u][j] = v[u] \quad \text{容量至少 } j \ge w[u]$

1. **合并每个子树**：

$f[u][j] = \max_{0 \le k \le j - w[u]} \Big( f[u][j - k] + f[v][k] \Big)$

- j：父节点当前容量
- k：分配给子树 v 的容量
- $f[u][j-k]$：父节点 + 已处理子树占用容量
- $f[v][k]$：子树在容量 k 内的最大价值

**直观理解**：父节点容量 = 自己占 + 给子树分配的容量 → 求所有可能分配的最大价值

------

## 4️⃣ 初始化

- **叶子节点**：没有子节点，$f[u][j] = v[u]（j >= w[u]）$，其他容量 $f[u][j] = 0$
- **非叶子节点**：初始也可以先放自己，再通过子树合并更新

------

## 5️⃣ 计算顺序

- **DFS 遍历树**（后序遍历）
  - 先处理子节点
  - 再合并到父节点

> ⚡ 为什么后序？
>
> - 因为父节点合并子树时，需要子树的 f[v] 已经算好

------

## 6️⃣ 答案

- 背包容量上限 W，容量可以不满
- 根节点 $f[root][j] $存储容量 j 内最大价值
- 最大价值 =

$\text{答案} = \max_{0 \le j \le W} f[root$][j]

> ⚡ 不直接用$ f[root][W] $是因为容量可以不满，最大价值可能在 j < W

------

## 7️⃣ Python 模板（五部曲版）

```python
def tree_knapsack(n, W, w, v, children):
    # 2️⃣ 定义状态 f[u][j]
    f = [[0]*(W+1) for _ in range(n+1)]

    # DFS 合并子树
    def dfs(u):
        # 4️⃣ 初始化：先放自己
        for j in range(w[u], W+1):
            f[u][j] = v[u]

        # 3️⃣ 状态转移：合并子树
        for child in children[u]:
            dfs(child)
            for j in range(W, w[u]-1, -1):         # 父节点容量倒序
                for k in range(0, j - w[u] + 1):  # 分配给子树的容量
                    f[u][j] = max(f[u][j], f[u][j - k] + f[child][k])#为什么不用v[u]，因为可能有多个子节点。

    root = 1
    dfs(root)

    # 6️⃣ 答案
    return max(f[root])
```

------

### 🔑 五部曲总结表

| 步骤       | 对应树形背包                                         |
| ---------- | ---------------------------------------------------- |
| 1️⃣ 明确问题 | 树形依赖 + 背包容量 + 最大价值                       |
| 2️⃣ 定义状态 | $f[u][j] = 子树 u 容量 j 内最大价值$                 |
| 3️⃣ 状态转移 | $f[u][j] = max(f[u][j-k] + f[v][k])，枚举子树容量 k$ |
| 4️⃣ 初始化   | $f[u][j] = v[u]（j >= w[u]）$                        |
| 5️⃣ 计算顺序 | DFS 后序遍历                                         |
| 6️⃣ 答案     | max(f[root])，容量可不满                             |





------

# 八、树上父子互斥背包（树形独立集背包）

**父子节点互斥**的情况：**父子节点不能同时选**。这种情况和树形背包正好相反（树形背包是选子必须选父），它属于 **树形背包的变种 → 树上的独立集问题**。

## 1️⃣ 问题描述

- 有 n 个节点（物品），每个节点 i：
  - 重量 w[i]
  - 价值 v[i]
- 树结构表示依赖关系，但 **父子不能同时选**
- 背包容量 W
- 求在容量 W 内的最大价值

> 注意区别：
>
> - 树形背包：选子必须选父
> - 这里：选子 **不能** 选父 → 父子互斥

------

## 2️⃣ 状态设计（树形 DP）

这是经典**树形独立集 + 背包**问题：

- 定义状态：

$$
f[u][j][0] = \text{子树 u 在容量 j 内，u 不被选的最大价值}
$$

$$
f[u][j][1] = \text{子树 u 在容量 j 内，u 被选的最大价值}
$$



- [0] 表示节点 u **不选**
- [1] 表示节点 u **选**

------

## 3️⃣ 状态转移

1. **节点不选 u**：

- 子节点可以选或不选

$$
f[u][j][0] = \max_{\text{容量分配}} \sum_{v \in children[u]} \max(f[v][k_v][0], f[v][k_v][1])
$$

1. **节点选 u**：

- 子节点 **必须不选**

$$
f[u][j][1] = v[u] + \max_{\text{容量分配}} \sum_{v \in children[u]} f[v][k_v][0]
$$

- 容量约束：

$\sum_v k_v + w[u]*\text{(u选)} \le j$

------

## 4️⃣ Python 模板（二维容量 + 选/不选状态）

```python
def tree_exclusive_knapsack(n, W, w, v, children):
    f = [[[0] * 2 for _ in range(W + 1)] for _ in range(n + 1)]

    def dfs(u):
        # ✅ 完整初始化
        for j in range(W + 1):
            f[u][j][0] = 0
            f[u][j][1] = v[u] if j >= w[u] else 0
        
        for child in children[u]:
            dfs(child)
            
            # ✅ 处理所有容量
            for j in range(W, -1, -1):
                # 选u的状态
                if j >= w[u]:
                    for k in range(j - w[u] + 1):
                        f[u][j][1] = max(f[u][j][1], f[u][j-k][1] + f[child][k][0])
                
                # 不选u的状态
                tmp = f[u][j][0]
                for k in range(j + 1):
                    tmp = max(tmp, f[u][j-k][0] + max(f[child][k][0], f[child][k][1]))
                f[u][j][0] = tmp

    dfs(1)
    return max(max(f[1][j][0], f[1][j][1]) for j in range(W + 1))
```

> ⚠️ 注意：
>
> - 这是二维容量 + 二选状态
> - 时间复杂度较高，需要优化容量枚举（滚动数组、二进制拆分等）

------

## 5️⃣ 核心理解

- **状态 [0]/[1]** = 当前节点是否选
- **父子互斥** → 当父节点选时，子节点只能不选
- **最大价值** → 枚举所有容量分配 + 状态选择
- 根节点最后取 `max(f[root][0][j], f[root][1][j])`

------

💡 总结：

- 树形背包：选子必须选父
- 树上父子互斥背包：选子不能选父 → 用“选/不选”状态
- 都是树形 DP，只是状态定义和状态转移不同

------

如果你愿意，我可以画一棵小树 + 表格，**展示父子互斥背包每个节点选/不选状态的 DP 更新过程**，让你直观理解为什么要 `[0]/[1]` 两个状态，以及容量如何分配。

你希望我画吗？

# 九
